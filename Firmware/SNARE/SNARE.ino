/*
HAGIWO MOD2 Snare Ver1.0

  • TR-808-style digital snare: sine-wave with pitch envelope + blue noise
  • 3 potentiometers × 2 modes  →  6 user parameters
  • Accent input (GPIO 0) : HIGH = −6 dB (0.5× level)
  • One-shot playback : 4 096 samples, 0.3 s total length
  • Anti-click edges : 2 % cosine fade-in / 10 % fade-out
  • All 6 parameters stored in on-board flash (EEPROM emulation)
  • CC0 1.0 — Public-domain.  Test thoroughly on your own hardware!

  --Pin assign---
POT1     A0       Mode0: Sin Pitch           | Mode1: Sine Pitch-env decay time
POT2     A1       Mode0: Sine level          | Mode1: Sine Pitch-env amount
POT3     A2       Mode0: Noise decay time    | Mode1: Sine decay time
IN1      GPIO7    Trig in
IN2      GPIO0    Accent  – level × 0.5 when HIGH
CV       A2       Shared with POT3
OUT      GPIO1    Audio PWM output (10‑bit)
BUTTON   GPIO6    Mode toggle & parameter save
LED      GPIO5    Mode indicator (ON = Mode 1)
EEPROM   save 6 parameter

CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
You can copy, modify, distribute and perform the work, even for commercial purposes, all without asking permission.

Most of the source code was generated by AI.
Although the code has been tested, it may still exhibit unstable behavior or contain incorrect comments.


------------------------------------------------------------------------------
*/

#include <Arduino.h>
#include "hardware/pwm.h"  // direct PWM register access
#include "hardware/irq.h"  // IRQ helpers
#include <math.h>
#include <EEPROM.h>  // flash-based key/value store
#include <stdlib.h>  // rand()

/*------------------------------- Fixed compile-time constants -------------*/
constexpr int TABLE_SIZE = 4096;  // samples per shot
constexpr float TABLE_INV = 1.0f / (TABLE_SIZE - 1);

const float SYS_CLOCK = 150'000'000.0f;  // RP2040 core clock (Hz)
const float NOTE_LEN = 0.3f;             // one-shot length (s)
const float BASE_INC = (TABLE_SIZE * 4096.0f) / (NOTE_LEN * SYS_CLOCK);
const float DT = NOTE_LEN / TABLE_SIZE;     // seconds per sample
const float FULL_SCALE = 1023.0f;           // 10-bit PWM range
const float MID_LEVEL = FULL_SCALE / 2.0f;  // centre (silence)

/*--------------------------- 6 real-time user parameters ------------------*/
/* MODE-0 (LED OFF) */
volatile float pitchEnvDecay = 0.01f;  // decay of pitch envelope (0–0.03 s)
volatile float noiseDecay = 0.06f;     // blue-noise decay (0.02–0.12 s)
volatile float sinVol = 0.8f;          // sine level 0–1
/* MODE-1 (LED ON)  */
volatile float sinPitch = 330.0f;   // base pitch (Hz)
volatile float pitchEnvAmt = 0.5f;  // envelope depth 0–1
volatile float sinDecay = 0.05f;    // sine decay (0.001–0.101 s)

/*------------------------- run-time playback state ------------------------*/
volatile bool accentState = false;  // HIGH = −6 dB
volatile bool noteOn = false;       // true while streaming
volatile float phase = 0.0f;        // fractional table index
constexpr float softClipK = 1.5f;   // tanh soft-clip strength

/*------------------------------ audio buffers -----------------------------*/
uint16_t rawTable[TABLE_SIZE];    // 0…FULL_SCALE before clicks fixed
uint16_t finalTable[TABLE_SIZE];  // final table streamed by PWM

/*---------------------- PWM slice numbers (set in setup) ------------------*/
uint sliceAudio;  // GPIO1  : PWM-B → speaker / output jack
uint sliceTimer;  // GPIO2  : dummy timer to generate IRQ

/*-------------------------------------------------------------------------*/
/*                            PWM wrap ISR                                 */
/*-------------------------------------------------------------------------*/
/* Called at 150 MHz / 4096 ≈ 36.6 kHz — streams the one-shot table.        */
void on_pwm_wrap() {
  pwm_clear_irq(sliceTimer);  // acknowledge IRQ

  if (!noteOn) {  // idle → mid-rail
    pwm_set_chan_level(sliceAudio, PWM_CHAN_B, (uint16_t)MID_LEVEL);
    return;
  }

  /* Linear-interpolated lookup (cheap sinc-like smoothing) */
  uint32_t i = (uint32_t)phase;
  float frac = phase - i;
  float y = finalTable[i] * (1.0f - frac)
            + finalTable[(i + 1) & (TABLE_SIZE - 1)] * frac;

  pwm_set_chan_level(sliceAudio, PWM_CHAN_B, (uint16_t)y);

  phase += BASE_INC;          // advance playhead
  if (phase >= TABLE_SIZE) {  // stop after one cycle
    noteOn = false;
    phase = 0.0f;
    pwm_set_chan_level(sliceAudio, PWM_CHAN_B, (uint16_t)MID_LEVEL);
  }
}

/*-------------------------------------------------------------------------*/
/*                        Wavetable (one-shot) builder                      */
/*-------------------------------------------------------------------------*/
/*
   Generates 4 096 samples consisting of:

     • Sine: frequency sweeps downwards according to pitch envelope
     • Blue noise: 1-pole HPF of white noise (white[n] − white[n-1])
     • Both components decay exponentially using their own time constants
*/
void make_wavetable() {
  const float twoPi = 2.0f * PI;
  float phaseS = 0.0f;     // sine phase accumulator
  float prevNoise = 0.0f;  // for blue-noise differentiator

  /* Pre-compute exponentials for fast per-sample decay. */
  float tauPitch = pitchEnvDecay < 0.0005f ? 0.0005f : pitchEnvDecay;
  const float expPitch = expf(-DT / tauPitch);    // pitch-env decay
  const float expSin = expf(-DT / sinDecay);      // sine amp decay
  const float expNoise = expf(-DT / noiseDecay);  // noise amp decay

  float envPitch = 1.0f;  // envelope multipliers (start at 1)
  float envSin = 1.0f;
  float envNoise = 1.0f;

  for (int i = 0; i < TABLE_SIZE; ++i) {

    /* --- Sine component -------------------------------------------------- */
    float freq = sinPitch * (1.0f - pitchEnvAmt * (1.0f - envPitch));
    phaseS += twoPi * freq * DT;
    float s = sinf(phaseS) * envSin;

    /* --- Blue noise component ------------------------------------------- */
    float white = ((float)rand() / RAND_MAX) * 2.0f - 1.0f;  // −1…1
    float blue = (white - prevNoise) * envNoise;
    prevNoise = white;

    /* --- Mix and quantise to 10-bit PWM range --------------------------- */
    float mix = s * sinVol + blue * (1.0f - sinVol);
    rawTable[i] = (uint16_t)((mix + 1.0f) * (FULL_SCALE / 2.0f));

    /* --- Exponential decay updates -------------------------------------- */
    envPitch *= expPitch;
    envSin *= expSin;
    envNoise *= expNoise;
  }
}

/*-------------------------------------------------------------------------*/
/*                                Setup                                     */
/*-------------------------------------------------------------------------*/
void setup() {
  /* -------- Restore parameters from flash ---------- */
  EEPROM.begin(64);
  {
    float t;
    EEPROM.get(0, t);
    pitchEnvDecay = t;
  }
  {
    float t;
    EEPROM.get(4, t);
    noiseDecay = t;
  }
  {
    float t;
    EEPROM.get(8, t);
    sinVol = t;
  }
  {
    float t;
    EEPROM.get(12, t);
    sinPitch = t;
  }
  {
    float t;
    EEPROM.get(16, t);
    pitchEnvAmt = t;
  }
  {
    float t;
    EEPROM.get(20, t);
    sinDecay = t;
  }

  make_wavetable();  // build initial table
  memcpy(finalTable, rawTable, sizeof(rawTable));

  /* -------- PWM configuration ------------------------------------------ */
  pinMode(1, OUTPUT);
  gpio_set_function(1, GPIO_FUNC_PWM);  // audio out
  pinMode(2, OUTPUT);
  gpio_set_function(2, GPIO_FUNC_PWM);  // timer
  sliceAudio = pwm_gpio_to_slice_num(1);
  sliceTimer = pwm_gpio_to_slice_num(2);

  pwm_set_clkdiv(sliceAudio, 1);
  pwm_set_wrap(sliceAudio, 1023);
  pwm_set_enabled(sliceAudio, true);

  pwm_set_clkdiv(sliceTimer, 1);
  pwm_set_wrap(sliceTimer, 4095);  // 150 MHz / 4096 ≈ 36.6 kHz IRQ
  pwm_set_enabled(sliceTimer, true);

  pwm_clear_irq(sliceTimer);
  pwm_set_irq_enabled(sliceTimer, true);
  irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);
  irq_set_enabled(PWM_IRQ_WRAP, true);

  /* -------- GPIO directions -------------------------------------------- */
  pinMode(7, INPUT);         // trigger input
  pinMode(0, INPUT);         // accent input (HIGH = accent)
  pinMode(6, INPUT_PULLUP);  // mode/select button
  pinMode(5, OUTPUT);        // mode LED
}

/*-------------------------------------------------------------------------*/
/*                Trigger ISR (inline lambda registration)                  */
/*-------------------------------------------------------------------------*/
void setupTrigger() {
  attachInterrupt(
    digitalPinToInterrupt(7), []() {
      /* ---------- Rising edge detected ---------- */
      noteOn = true;
      phase = 0.0f;
      accentState = digitalRead(0);  // sample accent pin

      /* Disable audio ISR while rebuilding the table to avoid conflicts.   */
      irq_set_enabled(PWM_IRQ_WRAP, false);
      make_wavetable();

      /* ---------------- Post-processing: soft-clip + click killer -------- */
      const int fadeInEnd = TABLE_SIZE * 0.02f;     // 2 %
      const int fadeOutStart = TABLE_SIZE * 0.90f;  // last 10 %
      const int fadeOutDen = TABLE_SIZE - 1 - fadeOutStart;
      const float invHalf = 2.0f / FULL_SCALE;
      const float clipNorm = 1.0f / tanhf(softClipK);
      const float halfScale = FULL_SCALE / 2.0f;
      const float level = accentState ? 0.5f : 1.0f;

      for (int i = 0; i < TABLE_SIZE; ++i) {
        /* Soft clipping */
        float bp = (rawTable[i] - MID_LEVEL) * invHalf;
        float y = tanhf(softClipK * bp) * clipNorm * level;
        y = y * halfScale + MID_LEVEL;

        /* 2 % fade-in (cosine) */
        if (i < fadeInEnd) {
          float mu = (float)i / fadeInEnd;
          y = MID_LEVEL + (y - MID_LEVEL) * (1.0f - cosf(mu * PI)) * 0.5f;
        }
        /* 10 % fade-out (cosine) */
        else if (i >= fadeOutStart) {
          float mu = (float)(i - fadeOutStart) / fadeOutDen;
          y += (MID_LEVEL - y) * (1.0f - cosf(mu * PI)) * 0.5f;
        }
        finalTable[i] = (uint16_t)y;
      }
      irq_set_enabled(PWM_IRQ_WRAP, true);  // restart audio ISR
    },
    RISING);
}

/*-------------------------------------------------------------------------*/
/*                            Main loop (UI)                               */
/*-------------------------------------------------------------------------*/
void loop() {
  static bool editMode = false;  // false = MODE0, true = MODE1
  static bool prevBtn = HIGH;
  bool currBtn = digitalRead(6);

  /* ---------- Button handling: toggle mode & save parameters ---------- */
  if (prevBtn == HIGH && currBtn == LOW) {  // falling edge
    editMode = !editMode;                   // toggle mode
    digitalWrite(5, editMode);              // update LED

    /* Save all six parameters to flash */
    {
      float t = pitchEnvDecay;
      EEPROM.put(0, t);
    }
    {
      float t = noiseDecay;
      EEPROM.put(4, t);
    }
    {
      float t = sinVol;
      EEPROM.put(8, t);
    }
    {
      float t = sinPitch;
      EEPROM.put(12, t);
    }
    {
      float t = pitchEnvAmt;
      EEPROM.put(16, t);
    }
    {
      float t = sinDecay;
      EEPROM.put(20, t);
    }
    EEPROM.commit();
  }
  prevBtn = currBtn;

  /* ---------- Potentiometer read & scaling --------------------------- */
  if (!editMode) { /* ===== MODE-0 ===== */

    /* POT1 : Base sine pitch 100–400 Hz (CW lowers) */
    int a0 = analogRead(A0);
    sinPitch = 100.0f + 300.0f * (a0 / 1023.0f);

    /* POT2 : Sine level 0–1 (CW quieter) */
    int a1 = analogRead(A1);
    sinVol = (1023.0f - a1) / 1023.0f;

    /* POT3 : Noise decay 10–80 ms (CW shorter) */
    int a2 = analogRead(A2);
    noiseDecay = 0.010f + 0.070f * ((1023.0f - a2) / 1023.0f);

  } else { /* ===== MODE-1 ===== */

    /* POT1 : Pitch-env decay 10–300 ms (CW longer) */
    int a0 = analogRead(A0);
    pitchEnvDecay = 0.01f + 0.29f * (a0 / 1023.0f);

    /* POT2 : Pitch-env amount 1 → 0 (CW smaller) */
    int a1 = analogRead(A1);
    pitchEnvAmt = (1023.0f - a1) / 1023.0f;

    /* POT3 : Sine decay 1–101 ms (CW shorter) */
    int a2 = analogRead(A2);
    sinDecay = 0.001f + 0.100f * ((1023 - a2) / 1023.0f);
  }

  delay(10);  // simple UI debounce & idle
}

/*-------------------------------------------------------------------------*/
/*     Constructor attribute registers the trigger ISR before setup()       */
/*-------------------------------------------------------------------------*/
__attribute__((constructor)) static void _initTrigger() {
  setupTrigger();
}
